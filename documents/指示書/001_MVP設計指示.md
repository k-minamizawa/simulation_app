# シミュレーションデモアプリケーション仕様書

## 1. プロジェクトの背景と目的

### 1.1 プロジェクト概要

本プロジェクトは、フォーラムでの展示を目的とした製造ラインシミュレーションデモアプリケーションの開発を目指すものです。このデモアプリケーションでは、現場の作業実績データを基にシミュレーションを実行し、その結果を可視化することで、データに基づいた将来予測と意思決定の重要性を来場者に体験していただきます。

### 1.2 デモの目的

本デモでは以下の体験を来場者に提供します：

- **UIからのシミュレーション実行**：来場者自身が操作してシミュレーションを開始できる
- **リアルタイム結果通知**：シミュレーション完了後、結果が自動的にUIにプッシュ通知され、画面が自動更新される
- **シナリオ比較による意思決定体験**：シナリオごとの結果をカード形式で比較・表示し、データに基づく意思決定を疑似体験できる

今回のデモでは、実際の現場データの取得は行わず、手動でデータを模擬します。シミュレーションでは、人員配置や残業時間といった条件を変えた複数のシナリオを実行し、それぞれの総人件費や納期遵守率を算出します。

### 1.3 用語定義

本仕様書で使用する主要な用語を定義します。

| 用語 | 説明 |
|------|------|
| **シナリオ** | 「人員を1名追加」「残業を1時間追加」など、シミュレーションの前提条件セット |
| **レプリケーション** | 同一シナリオで乱数を変えて複数回実行する際の各試行のこと。ランダムな要素を含むシミュレーションの信頼性を高めるために使用 |
| **ポーリング** | クライアントが定期的にサーバーへ問い合わせを行い、情報を更新する方式 |
| **WebSocket** | クライアントとサーバー間で双方向のリアルタイム通信を可能にする技術。サーバー側から能動的にクライアントへ情報をプッシュできる |

**技術選択の背景**：本プロジェクトではリアルタイム性を重視し、ポーリング方式ではなくWebSocketを採用しています。これにより、シミュレーション完了時に即座に全クライアントへ結果を通知できます。

## 2. システム構成

### 2.1 全体構成図

```
[フロントエンド (Next.js)]
        ↕ HTTP (REST API)
        ↕ WebSocket
[バックエンド (FastAPI)]
        ↕ SQL
[データベース (MySQL)]
        ↑ SQL (結果書き込み)
[仮想シミュレーションクライアント (Python)]
        → HTTP (完了通知)
        ↓
[バックエンド (FastAPI)]
```

### 2.2 コンポーネント構成

本システムは以下の4つの主要コンポーネントで構成されています：

#### フロントエンド (Next.js)

**役割**：ユーザーインターフェースの提供、ユーザー操作の受付、バックエンドとの通信

**主な機能**：

**シミュレーション開始画面 (`/start` 等)**：
- シミュレーション実行のトリガーとなる「シミュレーション開始」ボタンを設置
- ボタンクリック時に、バックエンドへシミュレーション開始APIリクエストを送信
- APIから正常な応答を受け取った後、結果閲覧画面 (`/results`) へ自動的に画面遷移させる

**結果閲覧画面 (`/results` 等)**：
- 画面読み込み時に、バックエンドとのWebSocket接続を確立・維持する
- 現在のシミュレーション結果をカード形式で表示する
- WebSocket経由で新しい結果データを受信した際に、画面表示をリアルタイムで更新する
- シミュレーション開始画面へ戻るためのナビゲーション機能を提供する

#### バックエンド (FastAPI)

**役割**：ビジネスロジックの実行、外部プロセス（仮想クライアント）の管理、データベースとの連携、フロントエンドとの通信

**主な機能**：
- フロントエンドからのHTTPリクエスト（シミュレーション開始等）の受付
- フロントエンドとのWebSocket接続を管理
- 仮想シミュレーションクライアントをバックグラウンドプロセスとして起動
- 仮想クライアントからの完了通知APIリクエストを受信
- DBから最新の結果データを取得・集計し、WebSocketを通じて全クライアントにブロードキャスト

バックエンドは、フロントエンド、仮想クライアント、データベース間の橋渡しとして、システム全体の調整役を担います。

#### データベース (MySQL)

**役割**：シミュレーションに関するマスターデータおよび結果データの永続的な保存

**主なデータ**：
- シナリオ情報（マスターデータ）
- シミュレーション結果（レプリケーションごとの詳細データ）

#### 仮想シミュレーションクライアント (Python Script)

**役割**：本来FlexSimが担うシミュレーション実行プロセスを模擬する

**主な機能**：
- 指定されたシナリオに基づき、ダミーのシミュレーション結果（総人件費、納期遵守率など）を生成
- 処理時間を模擬するための一定時間の待機
- 生成した結果データをデータベースに書き込む
- 処理完了後、バックエンドの完了通知用APIエンドポイントにリクエストを送信

**導入の意義**：この仮想クライアントの実装により、FlexSimの実装を待たずにシステム全体の動作確認とデモンストレーションが可能になります。将来的に実際のFlexSimと置き換える際も、データベースへの書き込みと完了通知APIの呼び出しというインターフェースを守れば、システムの他の部分を変更することなく統合できます。

## 3. 機能要件

### 3.1 ユーザーインターフェース (UI)

#### 3.1.1 シミュレーション開始画面

**パス**：`/start`（例）

**目的**：ユーザーにシミュレーションの開始を指示させる

**主要コンポーネント**：
- デモの概要説明文
- 「シミュレーション開始」ボタン

**動作フロー**：
1. ユーザーが「シミュレーション開始」ボタンをクリックする
2. フロントエンドはバックエンドの `POST /api/simulations` へリクエストを送信する
3. リクエストが成功した場合、フロントエンドは結果閲覧画面 (`/results`) へリダイレクトする
4. リクエストが失敗した場合、エラーメッセージを画面に表示する

#### 3.1.2 結果閲覧画面

**パス**：`/results`（例）

**目的**：DBに保存されているシミュレーション結果を一覧表示し、実行中のシミュレーションが完了すればリアルタイムで表示を更新する

**主要コンポーネント**：
- シナリオごとの結果表示カード
  - シナリオ名
  - トータルコスト（平均値）
  - 納期遵守率（平均値）
- 「再度シミュレーションを行う」ボタン

**動作フロー**：
1. ページがロードされると、フロントエンドはバックエンドの `WS /ws/results` へWebSocket接続を開始する
2. 同時に、初回表示データを取得するため `GET /api/results` へリクエストを送信し、取得したデータで画面を描画する
3. バックエンドからWebSocket経由で新しい結果データ（JSON配列）がプッシュされる
4. フロントエンドは受信したデータで画面の表示を更新する
5. ユーザーが「再度シミュレーションを行う」ボタンをクリックすると、シミュレーション開始画面 (`/start`) へ遷移する

**備考**：
- カードをクリックすることで、将来的に詳細画面へ遷移する（**今回は詳細画面の実装は範囲外**）

### 3.2 バックエンド機能

#### 3.2.1 リアルタイム通知機能

WebSocketを使用したリアルタイム通知機能を提供します。

**機能詳細**：
- WebSocket (`/ws/results`) を通じて、複数のクライアントとの接続を同時に維持・管理する
- 完了通知APIが呼び出された際、DBから最新の集計結果を取得し、接続中の全クライアントにJSON形式で送信（ブロードキャスト）する

この機能により、複数のユーザーが同時に画面を見ている場合でも、全員が同時に最新の結果を受け取ることができます。

#### 3.2.2 シミュレーション実行トリガー

非同期処理によるシミュレーション実行を実現します。

**機能詳細**：
- `/api/simulations` へのPOSTリクエストを受け付ける
- 仮想クライアントのPythonスクリプトを非同期のバックグラウンドプロセスとして実行する
- プロセスの起動後、クライアントには即座に「受付完了」のレスポンスを返す

この設計により、長時間かかる処理でもフロントエンドをブロックすることがありません。

#### 3.2.3 完了通知受付

シミュレーション完了をトリガーとした結果配信機能を提供します。

**機能詳細**：
- `/api/notify-completion` へのPOSTリクエストを受け付ける
- このリクエストをトリガーとして、リアルタイム通知機能（3.2.1）を実行する

## 4. データベース設計

### 4.1 ER図

```
[scenarios] 1 ----< ∞ [simulation_results]
    |                       |
    PK: scenario_id         PK: result_id
                            FK: scenario_id
```

### 4.2 テーブル定義

#### scenarios テーブル

**役割**：シミュレーションのシナリオ情報を管理する

| カラム名 | 型 | 制約 | 説明 |
|----------|-----|------|------|
| `scenario_id` | INT | PK, AI | シナリオID（主キー、自動採番） |
| `scenario_name` | VARCHAR(255) | NOT NULL | シナリオ名（例：「現状維持」「人員1名追加」） |
| `description` | TEXT | NULL | シナリオの詳細説明 |

#### simulation_results テーブル

**役割**：各シナリオのレプリケーションごとの実行結果を格納する

| カラム名 | 型 | 制約 | 説明 |
|----------|-----|------|------|
| `sim_result_id` | INT | PK, AI | 結果ID（主キー、自動採番） |
| `scenario_id` | INT | FK | scenariosテーブルのIDへの外部キー |
| `replication` | INT | NOT NULL | レプリケーション番号（1, 2, 3...） |
| `total_labor_costs` | DECIMAL(10, 2) | NOT NULL | 総人件費 |
| `ontime_delivery_rate` | DECIMAL(5, 4) | NOT NULL | 納期遵守率（0.0～1.0） |


**設計の意図**：この設計により、1つのシナリオに対して複数のレプリケーション結果を紐付けることができ、平均値や分散といった統計的な分析が可能になります。

## 5. API仕様

### 5.1 シミュレーション開始

**エンドポイント**：`POST /api/simulations`

**説明**：シミュレーションの実行をバックグラウンドで開始する

**リクエスト**：
- ボディ：なし

**レスポンス**：`200 OK`
```json
{
  "message": "Simulation started."
}
```

### 5.2 結果概要取得（初回読み込み用）

**エンドポイント**：`GET /api/results`

**説明**：現在DBに保存されている全シナリオの集計結果を返す

**リクエスト**：なし

**レスポンス**：`200 OK`
```json
[
  {
    "scenario_id": 1,
    "scenario_name": "現状シナリオ",
    "average_total_costs": 9249.12,
    "average_delivery_rate": 0.0
  }
]
```

### 5.3 完了通知受付（内部用）

**エンドポイント**：`POST /api/notify-completion`

**説明**：仮想クライアントから呼び出され、全クライアントへの結果通知をトリガーする

**リクエスト**：
- ボディ：なし

**レスポンス**：`200 OK`
```json
{
  "message": "Notification sent."
}
```

### 5.4 リアルタイム結果通知（WebSocket）

**エンドポイント**：`WS /ws/results`

**説明**：フロントエンドがリアルタイムで結果を受け取るためのWebSocket接続

**サーバーからクライアントへのメッセージ**：
- `/api/notify-completion` が呼ばれた際に送信される
- データ形式は `/api/results` のレスポンスと同じJSON配列

```json
[
  {
    "scenario_id": 1,
    "scenario_name": "現状シナリオ",
    "average_total_costs": 9249.12,
    "average_delivery_rate": 0.0
  }
]
```

## 6. システムの動作フロー

システム全体の動作を時系列で説明します。

### 6.1 初回アクセス（開始画面）

1. **初回アクセス**：ユーザーがブラウザでシミュレーション開始画面 (`/start`) にアクセス
2. **画面表示**：デモの概要説明と「シミュレーション開始」ボタンが表示される

### 6.2 シミュレーション開始フロー

1. **トリガー**：ユーザーが「シミュレーション開始」ボタンをクリック
2. **リクエスト送信**：開始画面 → バックエンド（`POST /api/simulations`）
3. **バックグラウンド起動**：バックエンドが仮想シミュレーションクライアントをバックグラウンドプロセスとして起動
4. **即時応答**：バックエンド → 開始画面（`200 OK` レスポンス）
5. **画面遷移**：開始画面はレスポンスを受け、ブラウザを結果閲覧画面 (`/results`) へリダイレクト

### 6.3 結果閲覧画面の初期化

1. **画面ロード**：結果閲覧画面 (`/results`) がロードされる
2. **WebSocket接続確立**：結果閲覧画面 → バックエンド（`WS /ws/results` へWebSocket接続要求）
3. **接続確立**：バックエンドが接続を確立
4. **初回データ取得**：結果閲覧画面 → バックエンド（`GET /api/results`）
5. **画面描画**：取得した既存の結果データでカードを表示

### 6.4 シミュレーション実行中

1. **独立動作**：仮想クライアントがバックグラウンドで独立して動作
2. **結果生成**：指定されたシナリオに基づいてダミーの結果データを生成
3. **DB書き込み**：生成したデータをデータベースに書き込む
4. **完了通知**：仮想クライアント → バックエンド（`POST /api/notify-completion`）

### 6.5 結果配信フロー

1. **完了通知受信**：バックエンドが完了通知を受信
2. **データ集計**：データベースから最新の集計結果を取得（各シナリオの複数レプリケーション結果から平均値を計算）
3. **ブロードキャスト**：バックエンド → 接続中の全結果閲覧画面クライアント（WebSocket経由）
4. **自動更新**：結果閲覧画面がWebSocketを通じて結果データを受信し、画面を自動更新
5. **結果表示**：新しく追加されたシナリオのカードが表示され、既存のカードも最新の値に更新される

### 6.6 再実行フロー

1. **トリガー**：ユーザーが結果閲覧画面の「再度シミュレーションを行う」ボタンをクリック
2. **画面遷移**：結果閲覧画面はブラウザをシミュレーション開始画面 (`/start`) へ遷移させる
3. **フロー再開**：6.1のフローに戻る

### 6.7 システムの利点

このように、**画面分離による明確なユーザーフロー**、**HTTPリクエストによる非同期処理の開始**、**WebSocketによるリアルタイム通知**を組み合わせることで、以下を実現しています：

- シミュレーション開始と結果閲覧を分離することで、ユーザーの操作意図が明確になる
- 長時間かかる処理でもユーザー体験を損なわない
- 複数のユーザーが同時に最新情報を共有できる
- ページリロードなしでシームレスに最新の結果を確認できる
- 再実行も容易に行える循環的なユーザーフローを提供

## 7. 実装フェーズ

本システムの構築を段階的に進めるため、以下のフェーズに分けて実装を行います。各フェーズは独立してテスト可能な単位とし、前フェーズの成果物を基盤として次フェーズを構築します。

### フェーズ1: バックエンド基盤構築 ✅

**目的**：FastAPIによるバックエンドの基礎構築とデータベース連携

**主な成果物**：
- FastAPIプロジェクト構造の作成
- データベース接続設定（SQLAlchemy）
- ORMモデル定義（`Scenario`, `SimulationResult`）
- Pydanticスキーマ定義（リクエスト/レスポンス型）
- 基本API実装（`GET /api/results`, `GET /api/scenarios`）
- CORS設定（フロントエンド連携準備）

**技術要素**：
- FastAPI, Uvicorn
- SQLAlchemy, PyMySQL
- Pydantic
- python-dotenv

**完了条件**：
- FastAPIサーバーが起動し、`http://localhost:8000/docs`で自動生成ドキュメントが閲覧可能
- `/api/results`エンドポイントがDBからデータを取得し、集計結果を返却
- `/api/scenarios`エンドポイントがシナリオ一覧を返却

**参考資料**：`documents/指示書/001-A01_フェーズ1実施報告および解説書.md`

---

### フェーズ2: バックエンド機能拡張

**目的**：リアルタイム通知機能とシミュレーション制御機能の実装

**主な実装内容**：
- WebSocket接続管理（コネクションマネージャー実装）
- WebSocketエンドポイント実装（`WS /ws/results`）
- シミュレーション開始API実装（`POST /api/simulations`）
- 完了通知受付API実装（`POST /api/notify-completion`）
- バックグラウンドタスク管理（外部プロセス起動機能）

**技術要素**：
- FastAPI WebSocket
- BackgroundTasks
- subprocess（Pythonプロセス起動）
- asyncio

**実装詳細**：

#### WebSocketコネクションマネージャー
複数クライアントとの接続を管理し、ブロードキャスト機能を提供するクラスを実装：
- 接続の追加・削除
- 全クライアントへのメッセージ送信（ブロードキャスト）
- 接続エラーハンドリング

#### シミュレーション開始処理
- フロントエンドからのPOSTリクエストを受付
- 仮想クライアントスクリプトを`subprocess`でバックグラウンド起動
- 即座にレスポンスを返却（非同期処理）

#### 完了通知処理
- 仮想クライアントからのPOSTリクエストを受付
- DBから最新の集計結果を取得
- WebSocket経由で全接続クライアントにブロードキャスト

**完了条件**：
- WebSocket接続が確立でき、サーバーからクライアントへメッセージ送信可能
- `/api/simulations`エンドポイントが外部プロセスを起動し、即座にレスポンス返却
- `/api/notify-completion`エンドポイントが結果をブロードキャスト

**テスト方法**：
- WebSocketクライアント（`websocat`等）で接続テスト
- Postman等でAPI動作確認

---

### フェーズ3: 仮想シミュレーションクライアント実装

**目的**：FlexSimの代替としてシミュレーション処理を模擬する独立プログラムの作成

**主な実装内容**：
- 独立したPythonスクリプト（`virtual_client.py`）の作成
- ダミーデータ生成ロジック実装
  - シナリオごとの総人件費・納期遵守率を乱数で生成
  - レプリケーション数に応じた繰り返し処理
- データベースへの結果書き込み機能
- 処理時間の模擬（一定時間のスリープ）
- バックエンドへの完了通知送信（`POST /api/notify-completion`）

**実装例**：
```python
# virtual_client.py
import time
import random
import requests
from database import SessionLocal
from models import SimulationResult

def run_simulation():
    # 3つのシナリオ × 3レプリケーション
    for scenario_id in [1, 2, 3]:
        for replication in range(1, 4):
            # ダミーデータ生成
            cost = random.uniform(8000, 12000)
            rate = random.uniform(0.75, 0.95)

            # DB書き込み
            db = SessionLocal()
            result = SimulationResult(
                scenario_id=scenario_id,
                replication=replication,
                total_labor_costs=cost,
                ontime_delivery_rate=rate
            )
            db.add(result)
            db.commit()
            db.close()

            time.sleep(2)  # 処理時間を模擬

    # 完了通知
    requests.post("http://localhost:8000/api/notify-completion")
```

**完了条件**：
- スクリプトが独立して実行可能
- DBに結果データが正常に書き込まれる
- 完了通知APIが正常に呼び出される
- バックエンドから起動した場合も正常動作

**テスト方法**：
- コマンドラインから直接実行して動作確認
- バックエンドの`/api/simulations`経由での起動確認

---

### フェーズ4: フロントエンド基盤構築

**目的**：Next.jsによるフロントエンドプロジェクトの初期セットアップ

**主な実装内容**：
- Next.jsプロジェクト作成（App Router使用）
- ディレクトリ構造の整備
- ルーティング設定（`/start`, `/results`）
- 共通レイアウトコンポーネント作成
- 基本スタイル設定（CSS変数定義）
  - メインカラー: #004d99
  - 背景カラー: #ffffff
  - テキストカラー: #333333
  - アクセントカラー: #C9A333

**ディレクトリ構造例**：
```
frontend/
├── src/
│   ├── app/
│   │   ├── start/
│   │   │   └── page.tsx
│   │   ├── results/
│   │   │   └── page.tsx
│   │   ├── layout.tsx
│   │   └── globals.css
│   ├── components/
│   │   ├── Button.tsx
│   │   └── Card.tsx
│   └── lib/
│       └── api.ts
└── package.json
```

**技術要素**：
- Next.js 14+ (App Router)
- React 18+
- TypeScript
- CSS Modules または Tailwind CSS

**完了条件**：
- Next.jsサーバーが起動し、`http://localhost:3000`でアクセス可能
- `/start`と`/results`の基本ページが表示される
- カラースキームが適用されている

---

### フェーズ5: フロントエンド機能実装

**目的**：ユーザーインターフェースとバックエンド連携機能の実装

**主な実装内容**：

#### シミュレーション開始画面（`/start`）
- デモ概要説明文の表示
- 「シミュレーション開始」ボタン実装
- ボタンクリック時の処理：
  - `POST /api/simulations`へのリクエスト送信
  - 成功時に`/results`へリダイレクト
  - エラー時のエラーメッセージ表示

**実装例**：
```typescript
// app/start/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

export default function StartPage() {
  const router = useRouter();
  const [error, setError] = useState('');

  const handleStart = async () => {
    try {
      const res = await fetch('http://localhost:8000/api/simulations', {
        method: 'POST',
      });
      if (res.ok) {
        router.push('/results');
      } else {
        setError('シミュレーション開始に失敗しました');
      }
    } catch (err) {
      setError('サーバーとの通信に失敗しました');
    }
  };

  return (
    <div>
      <h1>シミュレーションデモ</h1>
      <p>シミュレーション説明文...</p>
      <button onClick={handleStart}>シミュレーション開始</button>
      {error && <p>{error}</p>}
    </div>
  );
}
```

#### 結果閲覧画面（`/results`）
- WebSocket接続管理の実装
- 初回データ取得（`GET /api/results`）
- シナリオ結果カードコンポーネント実装
- WebSocketメッセージ受信時の画面更新
- 「再度シミュレーションを行う」ボタン実装

**実装例**：
```typescript
// app/results/page.tsx
'use client';

import { useEffect, useState } from 'react';

interface ScenarioResult {
  scenario_id: number;
  scenario_name: string;
  average_total_costs: number;
  average_delivery_rate: number;
}

export default function ResultsPage() {
  const [results, setResults] = useState<ScenarioResult[]>([]);

  useEffect(() => {
    // 初回データ取得
    fetch('http://localhost:8000/api/results')
      .then(res => res.json())
      .then(data => setResults(data));

    // WebSocket接続
    const ws = new WebSocket('ws://localhost:8000/ws/results');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setResults(data);
    };

    return () => ws.close();
  }, []);

  return (
    <div>
      <h1>シミュレーション結果</h1>
      <div className="card-container">
        {results.map(result => (
          <div key={result.scenario_id} className="card">
            <h3>{result.scenario_name}</h3>
            <p>総人件費: ¥{result.average_total_costs.toFixed(2)}</p>
            <p>納期遵守率: {(result.average_delivery_rate * 100).toFixed(1)}%</p>
          </div>
        ))}
      </div>
      <button onClick={() => window.location.href = '/start'}>
        再度シミュレーションを行う
      </button>
    </div>
  );
}
```

**技術要素**：
- React Hooks（`useState`, `useEffect`）
- Fetch API
- WebSocket API
- Next.js Router（`useRouter`）

**完了条件**：
- シミュレーション開始ボタンが動作し、バックエンドAPIを呼び出せる
- 結果閲覧画面でWebSocket接続が確立できる
- 初回データが正常に表示される
- WebSocket経由で結果更新が反映される
- ページ間の遷移が正常に動作する

---

### フェーズ6: 統合テスト・最終調整

**目的**：システム全体の動作確認と品質向上

**主な実施内容**：

#### エンドツーエンドテスト
1. **正常系フロー確認**
   - `/start`画面でボタンクリック
   - `/results`画面へ自動遷移
   - WebSocket接続確立
   - 仮想クライアントがバックグラウンド実行
   - 結果データがリアルタイムで表示更新

2. **複数クライアント同時接続テスト**
   - 複数ブラウザで同時に`/results`を開く
   - 1つのブラウザでシミュレーション開始
   - すべてのブラウザで同時に結果が更新されることを確認

3. **異常系テスト**
   - バックエンドサーバー停止時の挙動
   - データベース接続エラー時の挙動
   - WebSocket切断時の再接続動作

#### UI/UX調整
- ローディング表示の追加
- エラーメッセージの改善
- レスポンシブデザインの調整
- カラースキームの最終確認
- アニメーション効果の追加（オプション）

#### エラーハンドリング強化
- バックエンド：
  - データベース接続エラー処理
  - WebSocket接続エラー処理
  - プロセス起動失敗時の処理
- フロントエンド：
  - API通信エラー表示
  - WebSocket再接続ロジック
  - タイムアウト処理

#### パフォーマンス確認
- シミュレーション処理時間の計測
- WebSocketメッセージ配信遅延の確認
- データベースクエリのパフォーマンス確認

#### ドキュメント整備
- セットアップ手順書の作成
- デモ実施手順書の作成
- トラブルシューティングガイド

**完了条件**：
- すべての正常系フローが問題なく動作
- 複数クライアントで同時にリアルタイム更新が確認できる
- 主要な異常系に対するエラーハンドリングが実装されている
- デモ実施に必要なドキュメントが揃っている

---

### 補足：フェーズ間の依存関係

```
フェーズ1（バックエンド基盤）
    ↓
フェーズ2（バックエンド機能拡張）
    ↓
フェーズ3（仮想クライアント）
    ↓
フェーズ4（フロントエンド基盤）
    ↓
フェーズ5（フロントエンド機能）
    ↓
フェーズ6（統合テスト）
```

各フェーズは前フェーズの完了を前提とします。ただし、フェーズ4とフェーズ5は、フェーズ2完了後であれば並行して進めることも可能です。