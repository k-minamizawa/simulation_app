# 今後の開発計画と提案

**作成日**: 2025年10月2日
**対象**: フェーズ5完了後の開発方針

---

## 1. ユーザーからのフィードバック

### 1.1 データ管理に関する課題

**課題**:
> いつどのシミュレーションの結果かわからなくなる

**具体的な問題点**:
- 現在のシステムでは、シミュレーションを複数回実行すると、結果がデータベースに蓄積される
- 初回のシミュレーション結果と2回目以降の結果が混在する
- どの結果が最新なのか、いつ実行した結果なのかが判別できない
- 展示会のデモでは、各来場者に同じ初期状態から体験してもらいたい

### 1.2 機能拡張の要望

**要望1**: シナリオ詳細画面の追加
- カード（シナリオ）をクリックすると、そのシナリオの詳細結果を表示
- レプリケーションごとの結果の違いを確認できる

**要望2**: ガントチャート表示
- `frontend/src_backup/app/page.tsx`にある鉄道車両製造スケジュールのガントチャートを参考に実装
- **表示内容**:
  - 作業者別または車両別の切り替え表示
  - タスクバーによる工程の可視化
  - 開始時刻・終了時刻・担当者の表示
  - 複数車両タイプの色分け表示
  - 時間軸（日別・時間別）での表示

---

## 2. 提案: MVPにおけるデータベース初期化機能

### 2.1 提案の概要

**提案内容**:
> シミュレーションを実行するたびに、データベースのレコードを初期化する

**メリット**:
- ✅ 常にクリーンな状態からシミュレーションを開始できる
- ✅ 展示会で来場者ごとに同じ体験を提供できる
- ✅ デモの再現性が高まる
- ✅ データの一貫性が保たれる
- ✅ 実装がシンプル（MVPに適している）

**デメリット**:
- ❌ 過去の実行結果を保持できない（展示会デモでは問題なし）
- ❌ 将来的に履歴機能を追加する場合は、設計変更が必要

### 2.2 実装方針

#### オプションA: シミュレーション開始時に初期化（推奨）

**実装箇所**: `backend/main.py` の `POST /api/simulations`

```python
@app.post("/api/simulations")
async def start_simulation(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    # 既存の結果データを削除
    db.query(models.SimulationResult).delete()
    db.commit()

    # シミュレーション開始
    background_tasks.add_task(run_simulation_process)
    return {"message": "Simulation started. Previous results cleared."}
```

**メリット**:
- シミュレーション開始ボタンを押した時点で初期化される
- ユーザーの意図が明確（シミュレーション開始 = 新しいデータで開始）

#### オプションB: 専用の初期化ボタンを追加

**実装箇所**: フロントエンドに「リセット」ボタンを追加

**メリット**:
- 初期化のタイミングをユーザーが制御できる
- デバッグ時に便利

**デメリット**:
- UIが複雑になる
- ユーザーが操作を忘れる可能性がある

**推奨**: オプションA（自動初期化）をMVPとして採用し、必要に応じてオプションBを追加

### 2.3 将来的な拡張を見据えた設計

**中長期的には、以下の機能が考えられる**:

#### シミュレーション実行セッションの管理

```sql
-- 将来的なテーブル設計案
CREATE TABLE simulation_sessions (
    session_id INT PRIMARY KEY AUTO_INCREMENT,
    session_name VARCHAR(255),
    executed_at DATETIME,
    executed_by VARCHAR(255)
);

-- simulation_resultsにsession_idを追加
ALTER TABLE simulation_results
ADD COLUMN session_id INT,
ADD FOREIGN KEY (session_id) REFERENCES simulation_sessions(session_id);
```

**利点**:
- 複数回のシミュレーション実行結果を保持できる
- セッションごとに結果を比較できる
- 履歴管理が可能

**MVPでは不要だが、将来的な拡張の方向性として検討**

---

## 3. 機能拡張計画: シナリオ詳細画面

### 3.1 画面設計

#### 画面遷移

```
[結果閲覧画面 /results]
    │
    │ カードクリック
    ↓
[シナリオ詳細画面 /results/:scenario_id]
    │
    │ 戻るボタン
    ↓
[結果閲覧画面 /results]
```

#### 表示内容

**基本情報セクション**:
- シナリオ名
- シナリオ説明
- 平均総人件費
- 平均納期遵守率

**レプリケーション詳細セクション**:
- レプリケーションごとの結果を表形式で表示

| レプリケーション | 総人件費 | 納期遵守率 |
|----------------|---------|-----------|
| 1 | ¥8,940.82 | 89.56% |
| 2 | ¥9,739.89 | 81.84% |
| 3 | ¥8,319.39 | 94.42% |
| **平均** | **¥9,000.03** | **88.61%** |

**ガントチャートセクション**:
- タスクのスケジュールを視覚化
- 各工程の開始時刻、終了時刻、担当者を表示

### 3.2 技術スタック

#### ガントチャート表示の実装方針

**参考実装**: `frontend/src_backup/app/page.tsx`

**実装アプローチ**:
`src_backup`に既に完成度の高いガントチャート実装があるため、**カスタムコンポーネントとして実装**することを推奨します。

**src_backup実装の特徴**:
- ✅ Pure React実装（外部ライブラリ不要）
- ✅ shadcn/uiコンポーネント使用（統一感のあるUI）
- ✅ TailwindCSS（既存プロジェクトと同じスタイリング）
- ✅ 鉄道車両製造スケジュール管理の実績コード
- ✅ 作業者別/車両別の切り替え表示機能
- ✅ 複数車両タイプの色分け表示
- ✅ 日別・時間別の詳細タイムライン
- ✅ ホバー時の詳細情報表示（Tooltip）

**主要な技術要素**:
```typescript
// データ構造
interface ManufacturingTask {
  id: string
  vehicleId: string        // 車両ID（シミュレーションではワークID）
  vehicleType: 1 | 2 | 3   // 車両タイプ（シミュレーションではシナリオID）
  processName: string       // 工程名
  workerName: string        // 作業者名
  startDay: number          // 開始日
  startTime: string         // 開始時刻 "HH:MM"
  endDay: number            // 終了日
  endTime: string           // 終了時刻 "HH:MM"
  duration: number          // 所要時間（日数）
}
```

**レイアウト構造**:
- ヘッダー: タイトル、週選択、表示モード切り替え
- タイムライングリッド: 日別・時間別のグリッド表示
- タスクバー: 絶対位置指定でタスクを表示
- 凡例: 車両タイプ（シナリオ）の色分け説明

**外部ライブラリとの比較**:

| 項目 | カスタム実装（src_backup） | frappe-gantt | react-gantt-chart |
|-----|--------------------------|--------------|-------------------|
| **依存関係** | なし（Pure React） | 必要 | 必要 |
| **カスタマイズ性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **学習コスト** | 低（既存コード活用） | 中 | 中 |
| **メンテナンス性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **プロジェクト適合性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |

**推奨**: **src_backupのカスタム実装を流用**（外部ライブラリ不要、カスタマイズ性が高い、既存UIと統一感）

#### データ構造

**バックエンドAPIのレスポンス例**:
```json
{
  "scenario_id": 1,
  "scenario_name": "現状維持シナリオ",
  "replications": [
    {
      "replication": 1,
      "total_labor_costs": 8940.82,
      "ontime_delivery_rate": 0.8956
    },
    ...
  ],
  "gantt_data": [
    {
      "task_id": "task-1",
      "task_name": "部品A組立",
      "start": "2024-01-01T08:00:00",
      "end": "2024-01-01T10:30:00",
      "progress": 100,
      "worker": "作業員1"
    },
    ...
  ]
}
```

### 3.3 実装優先度

**優先度1（高）**: レプリケーション詳細表示
- 実装が比較的簡単
- データ構造の変更が不要
- 既存のAPIで対応可能

**優先度2（中）**: ガントチャート表示
- データベーススキーマの拡張が必要
- 仮想クライアントの修正が必要
- ライブラリの学習が必要

**推奨スケジュール**:
1. フェーズ6: データベース初期化機能の実装
2. フェーズ7: シナリオ詳細画面（レプリケーション表示）
3. フェーズ8: ガントチャート表示機能

---

## 4. ガントチャート実装の技術的検討

### 4.1 必要なデータ要素

ガントチャートを表示するために、以下のデータが必要です：

**タスク情報**:
- タスクID
- タスク名（例: 部品A組立、検査、塗装）
- 開始時刻
- 終了時刻
- 進捗率（0〜100%）
- 担当者（作業員ID）
- 依存関係（前工程のタスクID）

**リソース情報**:
- 作業員ID
- 作業員名
- スキルレベル

### 4.2 データベース設計案

#### 新規テーブル: task_logs

```sql
CREATE TABLE task_logs (
    task_log_id INT PRIMARY KEY AUTO_INCREMENT,
    sim_result_id INT NOT NULL,
    task_name VARCHAR(255) NOT NULL,
    start_time DATETIME NOT NULL,
    end_time DATETIME NOT NULL,
    worker_id VARCHAR(50),
    progress DECIMAL(5, 2) DEFAULT 100.00,
    FOREIGN KEY (sim_result_id) REFERENCES simulation_results(sim_result_id)
);
```

**設計の意図**:
- `sim_result_id`で結果データと紐付け
- レプリケーションごとに異なるタスク実行順序を記録
- FlexSimからエクスポートされたタスクログを格納

### 4.3 src_backupコードのシミュレーションアプリへの適用

**src_backupの鉄道車両製造スケジュール → シミュレーション結果ガントチャート**

#### データマッピング

| 鉄道車両製造（src_backup） | シミュレーションアプリ |
|---------------------------|---------------------|
| 車両ID（N700S-001） | ワークID（Work-001） |
| 車両タイプ（1/2/3） | シナリオID（1/2/3） |
| 工程名（フレーム溶接） | タスク名（組立工程A） |
| 作業者名（溶接班A） | リソース名（作業員1） |
| 開始日時 | シミュレーション開始時刻 |
| 終了日時 | シミュレーション終了時刻 |

#### UI要素の流用

**1. 表示モード切り替え**:
```typescript
// src_backup: 作業者別 ⇔ 車両別
// シミュレーション: リソース別 ⇔ ワーク別
<Button onClick={() => setViewMode("resource")}>リソース別</Button>
<Button onClick={() => setViewMode("work")}>ワーク別</Button>
```

**2. 色分け**:
```typescript
// src_backup: 車両タイプ1/2/3
// シミュレーション: シナリオ1/2/3
const getScenarioColor = (scenarioId: number) => {
  switch (scenarioId) {
    case 1: return "bg-[var(--color-scenario-1)]"  // 現状維持
    case 2: return "bg-[var(--color-scenario-2)]"  // 人員増強
    case 3: return "bg-[var(--color-scenario-3)]"  // 効率改善
  }
}
```

**3. タスクバー配置計算**:
```typescript
// src_backupのgetTaskPosition関数をそのまま流用可能
const getTaskPosition = (task: SimulationTask) => {
  const totalSlots = 10 * 11 // 10日 × 11時間
  const startSlot = task.startDay * 11 + (parseInt(task.startTime.split(":")[0]) - 8)
  const endSlot = task.endDay * 11 + (parseInt(task.endTime.split(":")[0]) - 8)
  const left = (startSlot / totalSlots) * 100
  const width = ((endSlot - startSlot) / totalSlots) * 100
  return { left: `${left}%`, width: `${width}%` }
}
```

### 4.4 FlexSimとのデータ連携

**FlexSimからのデータエクスポート方法**:

#### オプション1: CSV出力
```flexscript
// FlexSimスクリプト例
Table taskLog = Table("TaskLog");
taskLog.exportToCSV("task_log.csv");
```

**Pythonで読み込み**:
```python
import csv
import pandas as pd

df = pd.read_csv("task_log.csv")
for index, row in df.iterrows():
    task_log = TaskLog(
        sim_result_id=sim_result_id,
        task_name=row['TaskName'],
        start_time=row['StartTime'],
        end_time=row['EndTime'],
        worker_id=row['WorkerID']
    )
    db.add(task_log)
db.commit()
```

#### オプション2: 直接データベース書き込み（将来的）
FlexSimから直接MySQLに書き込む（ODBC接続）

### 4.4 仮想クライアントでのダミーデータ生成

**短期的には、仮想クライアントでダミーのタスクログを生成**:

```python
import random
from datetime import datetime, timedelta

def generate_dummy_gantt_data(sim_result_id, db):
    tasks = ["部品A組立", "部品B組立", "検査", "塗装", "梱包"]
    start_time = datetime(2024, 1, 1, 8, 0, 0)

    for i, task_name in enumerate(tasks):
        duration = random.randint(30, 120)  # 30〜120分
        end_time = start_time + timedelta(minutes=duration)

        task_log = TaskLog(
            sim_result_id=sim_result_id,
            task_name=task_name,
            start_time=start_time,
            end_time=end_time,
            worker_id=f"worker-{random.randint(1, 5)}",
            progress=100.0
        )
        db.add(task_log)

        start_time = end_time  # 次のタスクは前のタスク終了後に開始

    db.commit()
```

### 4.5 フロントエンド実装例（src_backup流用）

```typescript
// frontend/src/components/SimulationGanttChart.tsx
'use client'

import { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Clock, Users, Package } from "lucide-react"

type ViewMode = "resource" | "work"

interface SimulationTask {
  id: string
  workId: string           // ワークID（例: Work-001）
  scenarioId: 1 | 2 | 3    // シナリオID
  processName: string       // タスク名（例: 組立工程A）
  resourceName: string      // リソース名（例: 作業員1）
  startDay: number          // 開始日
  startTime: string         // 開始時刻 "HH:MM"
  endDay: number            // 終了日
  endTime: string           // 終了時刻 "HH:MM"
  duration: number          // 所要時間（日数）
}

interface SimulationGanttChartProps {
  tasks: SimulationTask[]
  scenarioName: string
}

export default function SimulationGanttChart({
  tasks,
  scenarioName
}: SimulationGanttChartProps) {
  const [viewMode, setViewMode] = useState<ViewMode>("resource")

  const getScenarioColor = (scenarioId: 1 | 2 | 3) => {
    switch (scenarioId) {
      case 1: return "bg-blue-500"      // 現状維持
      case 2: return "bg-green-500"     // 人員増強
      case 3: return "bg-purple-500"    // 効率改善
    }
  }

  const getTaskPosition = (task: SimulationTask) => {
    const totalSlots = 10 * 11 // 10日 × 11時間/日
    const startSlot = task.startDay * 11 + (parseInt(task.startTime.split(":")[0]) - 8)
    const endSlot = task.endDay * 11 + (parseInt(task.endTime.split(":")[0]) - 8)
    const left = (startSlot / totalSlots) * 100
    const width = ((endSlot - startSlot) / totalSlots) * 100
    return { left: `${left}%`, width: `${width}%` }
  }

  // タスクをグループ化（リソース別またはワーク別）
  const groupedTasks = tasks.reduce((acc, task) => {
    const key = viewMode === "resource" ? task.resourceName : task.workId
    if (!acc[key]) acc[key] = []
    acc[key].push(task)
    return acc
  }, {} as Record<string, SimulationTask[]>)

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Clock className="w-5 h-5" />
            {scenarioName} - 製造スケジュール
          </CardTitle>
          <div className="flex bg-muted rounded-lg p-1">
            <Button
              variant={viewMode === "resource" ? "default" : "ghost"}
              size="sm"
              onClick={() => setViewMode("resource")}
            >
              <Users className="w-4 h-4 mr-2" />
              リソース別
            </Button>
            <Button
              variant={viewMode === "work" ? "default" : "ghost"}
              size="sm"
              onClick={() => setViewMode("work")}
            >
              <Package className="w-4 h-4 mr-2" />
              ワーク別
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {/* タイムライングリッド */}
        <div className="space-y-1">
          {Object.entries(groupedTasks).map(([groupKey, groupTasks]) => (
            <div key={groupKey} className="flex items-center">
              <div className="w-48 flex-shrink-0 pr-4">
                <div className="font-medium text-sm">{groupKey}</div>
                <div className="text-xs text-muted-foreground">
                  {groupTasks.length}タスク
                </div>
              </div>
              <div className="flex-1 relative h-12 bg-muted/30 rounded-md border">
                {/* タスクバー */}
                {groupTasks.map((task) => {
                  const position = getTaskPosition(task)
                  const colorClass = getScenarioColor(task.scenarioId)

                  return (
                    <div
                      key={task.id}
                      className={`absolute top-1 bottom-1 ${colorClass} rounded-sm flex items-center px-2 cursor-pointer hover:opacity-80`}
                      style={position}
                      title={`${task.processName} - ${viewMode === "resource" ? task.workId : task.resourceName}`}
                    >
                      <div className="text-xs text-white font-medium truncate">
                        {viewMode === "resource" ? task.workId : task.processName}
                      </div>
                    </div>
                  )
                })}
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
```

**使用例**:
```typescript
// シナリオ詳細画面（/results/[scenario_id]）
import SimulationGanttChart from '@/components/SimulationGanttChart'

export default function ScenarioDetailPage({ params }) {
  const [tasks, setTasks] = useState<SimulationTask[]>([])

  useEffect(() => {
    // バックエンドからタスクログを取得
    fetch(`http://localhost:8000/api/scenarios/${params.scenario_id}/gantt`)
      .then(res => res.json())
      .then(data => setTasks(data.tasks))
  }, [params.scenario_id])

  return (
    <div>
      <h1>シナリオ詳細</h1>
      <SimulationGanttChart
        tasks={tasks}
        scenarioName="現状維持シナリオ"
      />
    </div>
  )
}
```

---

## 5. 開発ロードマップ

### フェーズ6: 統合テスト・最終調整＋データ初期化機能（1週間）

**目的**: MVPの完成度を高め、展示会デモの準備を整える

**実施内容**:
1. データベース初期化機能の実装
   - `POST /api/simulations`でsimulation_resultsテーブルをクリア
   - フロントエンドでの動作確認
2. 複数ブラウザでの同時接続テスト
3. UI/UXの最終調整
4. エラーハンドリングの強化
5. パフォーマンス検証

**成果物**:
- ✅ 展示会デモ可能なMVP完成
- ✅ テストレポート
- ✅ デモ実施手順書

---

### フェーズ7: シナリオ詳細画面（レプリケーション表示）（1週間）

**目的**: 各シナリオの詳細情報を確認できる画面を追加

**実施内容**:
1. **バックエンド**: シナリオ詳細取得API実装
   - `GET /api/scenarios/:scenario_id` エンドポイント追加
   - レプリケーションごとの結果を返却
2. **フロントエンド**: シナリオ詳細画面実装
   - `/results/:scenario_id` ページ作成
   - レプリケーション結果の表形式表示
   - 統計情報の表示（平均、最大、最小、標準偏差）
3. **ルーティング**: Cardコンポーネントにクリックイベント追加

**API仕様例**:
```
GET /api/scenarios/1

Response:
{
  "scenario_id": 1,
  "scenario_name": "現状維持シナリオ",
  "description": "現在の人員配置でのシミュレーション",
  "replications": [
    {
      "replication": 1,
      "total_labor_costs": 8940.82,
      "ontime_delivery_rate": 0.8956
    },
    {
      "replication": 2,
      "total_labor_costs": 9739.89,
      "ontime_delivery_rate": 0.8184
    },
    {
      "replication": 3,
      "total_labor_costs": 8319.39,
      "ontime_delivery_rate": 0.9442
    }
  ],
  "statistics": {
    "avg_cost": 9000.03,
    "avg_delivery_rate": 0.8861,
    "std_cost": 730.45,
    "std_delivery_rate": 0.0632
  }
}
```

**成果物**:
- ✅ シナリオ詳細画面
- ✅ レプリケーション結果の可視化
- ✅ 統計情報の表示

---

### フェーズ8: ガントチャート表示機能（2週間）

**目的**: タスクスケジュールを視覚的に表示し、シミュレーション結果の理解を深める

**実施内容**:

#### 8-1. データベース拡張（3日）
1. `task_logs` テーブルの作成
2. マイグレーションスクリプト作成
3. ORMモデルの追加（`backend/models.py`）

#### 8-2. 仮想クライアントの拡張（2日）
1. ダミーのタスクログ生成機能追加
2. `virtual_client.py`の修正
3. 動作確認

#### 8-3. バックエンドAPI実装（2日）
1. `GET /api/scenarios/:scenario_id/gantt` エンドポイント追加
2. タスクログの取得と整形
3. JSON形式でのレスポンス

#### 8-4. フロントエンド実装（5日）
1. ガントチャートライブラリのインストール（frappe-gantt）
2. `GanttChart`コンポーネントの作成
3. シナリオ詳細画面への組み込み
4. スタイリングとレスポンシブ対応
5. 動作確認とテスト

#### 8-5. 統合テスト（2日）
1. エンドツーエンドテスト
2. パフォーマンス検証
3. バグフィックス

**成果物**:
- ✅ ガントチャート表示機能
- ✅ タスクログデータの管理
- ✅ 視覚的なスケジュール確認

---

### フェーズ9: FlexSim統合準備（将来的）

**目的**: 仮想クライアントをFlexSimに置き換える

**実施内容**:
1. FlexSimからのデータエクスポート機能実装
2. FlexSimスクリプトの開発
3. データ形式の調整
4. 統合テスト

**課題**:
- FlexSimの実装状況に依存
- データ形式の標準化が必要

---

## 6. 技術的な意見と推奨事項

### 6.1 データベース初期化について

**推奨**: シミュレーション開始時に自動初期化

**理由**:
1. **展示会デモに最適**: 来場者ごとに同じ体験を提供できる
2. **シンプル**: 実装が容易で、バグのリスクが低い
3. **直感的**: ユーザーの操作が明確（開始 = 新しいデータ）

**実装の注意点**:
- シナリオマスターデータ（`scenarios`テーブル）は削除しない
- 結果データ（`simulation_results`テーブル）のみを削除
- トランザクション管理を適切に行う

```python
@app.post("/api/simulations")
async def start_simulation(
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    try:
        # 既存の結果データを削除
        deleted_count = db.query(models.SimulationResult).delete()
        db.commit()

        logger.info(f"Deleted {deleted_count} previous simulation results")

        # シミュレーション開始
        background_tasks.add_task(run_simulation_process)

        return {
            "message": "Simulation started. Previous results cleared.",
            "deleted_count": deleted_count
        }
    except Exception as e:
        db.rollback()
        logger.error(f"Error starting simulation: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### 6.2 ガントチャート実装について

**推奨ライブラリ**: frappe-gantt

**理由**:
1. **無料**: MITライセンス、商用利用可能
2. **軽量**: バンドルサイズが小さい
3. **シンプル**: 学習コストが低い
4. **カスタマイズ可能**: 必要に応じて拡張できる

**代替案**: react-gantt-chart（よりReactネイティブなアプローチ）

**実装時の注意点**:
- タスクの時刻表示形式を統一（ISO 8601推奨）
- タイムゾーンの考慮（展示会では日本時間固定で問題なし）
- レスポンシブ対応（モバイル表示を考慮）

### 6.3 段階的な実装アプローチ

**推奨**: 機能を段階的に追加

**理由**:
1. **リスク分散**: 一度に多くの変更を加えず、段階的にテスト
2. **早期フィードバック**: 各フェーズで動作確認し、方向性を調整
3. **学習機会**: 新しい技術を段階的に習得

**推奨順序**:
```
フェーズ6（データ初期化） → フェーズ7（詳細画面） → フェーズ8（ガントチャート）
```

---

## 7. 懸念事項とリスク管理

### 7.1 データベース初期化に関するリスク

**リスク**: 誤って初期化ボタンを押してしまう

**対策（将来的）**:
- 確認ダイアログの表示
- 初期化前のバックアップ機能

**MVPでは**: 自動初期化のため、このリスクは低い

### 7.2 ガントチャート表示のパフォーマンス

**リスク**: タスク数が多い場合、レンダリングが遅くなる

**対策**:
- 仮想スクロール（Virtualization）の実装
- タスク数の制限（最大100タスク等）
- サーバーサイドでのデータフィルタリング

**MVPでは**: 限定的なタスク数（<50）を想定し、問題なし

### 7.3 FlexSim統合時のデータ形式の不一致

**リスク**: FlexSimのデータ形式が想定と異なる

**対策**:
- データ形式の標準化（JSON Schema等）
- データ変換層の実装
- FlexSim側との早期の仕様調整

**現時点**: 仮想クライアントで柔軟にデータ形式を調整可能

---

## 8. まとめと次のアクション

### 8.1 短期的なアクション（1週間以内）

1. **フェーズ6の開始**: データベース初期化機能の実装
   - `POST /api/simulations`の修正
   - 動作確認
   - ドキュメント更新

2. **統合テスト**: MVPとしての完成度を高める
   - 複数ブラウザテスト
   - エラーシナリオのテスト

3. **展示会準備**: デモ実施手順書の作成

### 8.2 中期的なアクション（1ヶ月以内）

1. **フェーズ7の実装**: シナリオ詳細画面
   - バックエンドAPI追加
   - フロントエンド画面作成
   - 動作確認

2. **フェーズ8の準備**: ガントチャート機能の設計
   - データベーススキーマ設計
   - ライブラリ選定
   - プロトタイプ作成

### 8.3 長期的なアクション（3ヶ月以内）

1. **フェーズ8の実装**: ガントチャート表示
2. **FlexSim統合準備**: データ連携仕様の策定
3. **追加機能検討**: ユーザーフィードバックを基にした改善

---

## 9. 付録: 参考資料

### 9.1 ガントチャート実装方法の比較

| 実装方法 | 依存関係 | カスタマイズ性 | 学習コスト | プロジェクト適合性 | 推奨度 |
|---------|---------|-------------|----------|----------------|-------|
| **カスタム実装（src_backup）** | なし | ⭐⭐⭐⭐⭐ | 低（既存コード） | ⭐⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** |
| frappe-gantt | 外部ライブラリ | ⭐⭐⭐ | 中 | ⭐⭐⭐ | ⭐⭐⭐ |
| react-gantt-chart | 外部ライブラリ | ⭐⭐⭐⭐ | 中 | ⭐⭐⭐ | ⭐⭐⭐ |
| dhtmlx-gantt | 外部ライブラリ | ⭐⭐⭐ | 高 | ⭐⭐ | ⭐⭐ |
| bryntum-gantt | 外部ライブラリ（有料） | ⭐⭐⭐⭐ | 高 | ⭐⭐ | ⭐（有料） |

**推奨理由（カスタム実装）**:
1. ✅ **既存コードの流用**: `frontend/src_backup/app/page.tsx`の実装をそのまま活用可能
2. ✅ **外部依存なし**: npmパッケージの追加不要、メンテナンスリスクが低い
3. ✅ **既存UIとの統一感**: shadcn/ui、TailwindCSSを使用し、既存画面と同じデザインシステム
4. ✅ **完成度の高い実装**: 鉄道車両製造スケジュール管理の実績コード
5. ✅ **柔軟なカスタマイズ**: 必要に応じて自由に拡張・修正可能

### 9.2 データベース初期化の実装パターン

**パターン1**: DELETE文を使用（推奨）
```python
db.query(SimulationResult).delete()
db.commit()
```

**パターン2**: TRUNCATE文を使用
```python
db.execute("TRUNCATE TABLE simulation_results")
db.commit()
```

**注意**: TRUNCATE はAUTO_INCREMENTをリセットするが、外部キー制約がある場合はエラーになる可能性がある

### 9.3 関連ドキュメント

- フェーズ1実施報告: `documents/指示書/001-A01_フェーズ1実施報告および解説書.md`
- フェーズ2実施報告: `documents/指示書/001-A02_フェーズ2実施報告および解説書.md`
- フェーズ5実施報告: `documents/指示書/001-A05_フェーズ5実施報告および解説書.md`
- MVP設計指示: `documents/指示書/001_MVP設計指示.md`

---

**作成者**: Claude Code
**最終更新**: 2025年10月2日
