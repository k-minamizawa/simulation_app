# フェーズ2実施報告および解説書

## 1. 実施概要

**実施日**: 2025年9月28日
**実施内容**: バックエンド機能拡張（WebSocketリアルタイム通知とシミュレーション制御機能）
**ステータス**: ✅ 完了

---

## 2. 実施内容の詳細

### 2.1 追加・修正したファイル一覧

| ファイル名 | 役割 | 変更内容 |
|-----------|------|---------|
| `backend/main.py` | FastAPIアプリケーション本体 | WebSocket機能、シミュレーション制御API、完了通知APIを追加 |
| `backend/test_program/test_websocket.py` | WebSocket接続テストプログラム | 新規作成 |

### 2.2 追加した機能一覧

1. **WebSocketコネクションマネージャー**
   - 複数のWebSocket接続を管理
   - 全クライアントへのブロードキャスト機能

2. **WebSocketエンドポイント** (`WS /ws/results`)
   - クライアントとのWebSocket接続を確立
   - リアルタイムデータ配信の受信端点

3. **シミュレーション開始API** (`POST /api/simulations`)
   - 外部プロセスをバックグラウンドで起動
   - 即座にレスポンスを返す非同期処理

4. **完了通知受付API** (`POST /api/notify-completion`)
   - シミュレーション完了をトリガーとして結果を集計
   - WebSocketで全クライアントにブロードキャスト

---

## 3. 技術解説

### 3.1 WebSocketコネクションマネージャー

**役割**: 複数のWebSocket接続を一元管理し、全クライアントへのメッセージ配信（ブロードキャスト）を実現

```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except Exception as e:
                print(f"Error broadcasting to a client: {e}")

manager = ConnectionManager()
```

**学習ポイント**:

#### 1. **非同期処理 (async/await)**
- `async def`: 非同期関数の定義。I/O待機時に他の処理を実行できる
- `await`: 非同期処理の完了を待機。待機中は他のタスクに制御を譲る
- WebSocketのような複数接続を扱う場合、非同期処理が必須

#### 2. **接続管理のデザインパターン**
- `List[WebSocket]`: 型ヒントで接続リストを明示
- `accept()`: WebSocket接続を受け入れ、ハンドシェイクを完了
- `append()/remove()`: 接続の追加・削除を動的に管理

#### 3. **エラーハンドリング**
```python
try:
    await connection.send_text(message)
except Exception as e:
    print(f"Error broadcasting to a client: {e}")
```
- 1つのクライアントへの送信エラーが全体に波及しないよう、個別に例外処理
- 接続が切れたクライアントへの送信は失敗するが、他のクライアントには影響しない

---

### 3.2 WebSocketエンドポイント

**役割**: クライアントからのWebSocket接続を受け付け、接続を維持する

```python
@app.websocket("/ws/results")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

**学習ポイント**:

#### 1. **@app.websocket デコレータ**
- HTTPではなくWebSocketプロトコルを使用するエンドポイントを定義
- 通常の`@app.get`や`@app.post`とは異なる動作

#### 2. **無限ループによる接続維持**
```python
while True:
    await websocket.receive_text()
```
- WebSocketは双方向通信のため、接続を維持し続ける必要がある
- `receive_text()`でクライアントからのメッセージを待機（今回は使用しない）
- この無限ループがないと、接続が即座に切断される

#### 3. **WebSocketDisconnect例外**
- クライアントが切断したときに発生する特殊な例外
- `finally`ではなく`except`で捕捉し、明示的にクリーンアップ処理を実行

**通常のHTTP vs WebSocket**:
| 特徴 | HTTP | WebSocket |
|------|------|-----------|
| 通信方向 | 単方向（リクエスト→レスポンス） | 双方向（サーバーからもプッシュ可能） |
| 接続 | 毎回新しい接続 | 1度確立したら維持 |
| リアルタイム性 | ポーリングが必要 | サーバーから即座にプッシュ |

---

### 3.3 シミュレーション開始API

**役割**: 外部のPythonプロセス（仮想シミュレーションクライアント）をバックグラウンドで起動

```python
import subprocess
import sys

def run_simulation_process():
    subprocess.Popen(
        [sys.executable, "virtual_client.py"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

@app.post("/api/simulations")
async def start_simulation(background_tasks: BackgroundTasks):
    background_tasks.add_task(run_simulation_process)
    return {"message": "Simulation started."}
```

**学習ポイント**:

#### 1. **BackgroundTasks**
- FastAPIが提供する機能で、レスポンス返却後にタスクを実行
- ユーザーを待たせることなく、長時間処理を開始できる

**動作フロー**:
```
1. クライアント → サーバー: POSTリクエスト
2. サーバー: background_tasks.add_task(関数)
3. サーバー → クライアント: 即座に200 OKレスポンス
4. サーバー: バックグラウンドでタスク実行
```

#### 2. **subprocess.Popen**
- 新しいプロセスを起動するPython標準ライブラリ
- `Popen`（Process Open）: プロセスを起動して、親プロセスは待たずに続行

**subprocess.run vs subprocess.Popen**:
| メソッド | 動作 | 用途 |
|---------|------|------|
| `run()` | プロセス完了まで待機 | 即座に結果が必要な処理 |
| `Popen()` | 起動後すぐに制御を返す | バックグラウンド処理 |

#### 3. **sys.executable**
- 現在のPythonインタープリタのパスを取得
- 仮想環境でも正しいPythonを使用できる
```python
# 例: C:\Users\XXX\AppData\Local\Programs\Python\Python311\python.exe
print(sys.executable)
```

---

### 3.4 完了通知受付API

**役割**: シミュレーション完了時に呼び出され、結果をすべてのWebSocket接続クライアントにブロードキャスト

```python
@app.post("/api/notify-completion")
async def notify_completion(db: Session = Depends(get_db)):
    results = (
        db.query(
            models.Scenario.scenario_id,
            models.Scenario.scenario_name,
            func.avg(models.SimulationResult.total_labor_costs).label("average_total_costs"),
            func.avg(models.SimulationResult.ontime_delivery_rate).label("average_delivery_rate"),
        )
        .join(models.SimulationResult, models.Scenario.scenario_id == models.SimulationResult.scenario_id)
        .group_by(models.Scenario.scenario_id, models.Scenario.scenario_name)
        .all()
    )

    result_data = [
        {
            "scenario_id": row.scenario_id,
            "scenario_name": row.scenario_name,
            "average_total_costs": float(row.average_total_costs),
            "average_delivery_rate": float(row.average_delivery_rate),
        }
        for row in results
    ]

    await manager.broadcast(json.dumps(result_data))

    return {"message": "Notification sent."}
```

**学習ポイント**:

#### 1. **データ変換パイプライン**
```
DB (Decimal型) → Python (dict) → JSON文字列 → WebSocket送信
```

#### 2. **float()変換の必要性**
```python
"average_total_costs": float(row.average_total_costs),
```
- SQLAlchemyのDecimal型は、そのままではJSONシリアライズできない
- `json.dumps()`を使う前に、JSON対応型（float, int, str等）に変換が必要

#### 3. **json.dumps()**
```python
await manager.broadcast(json.dumps(result_data))
```
- PythonのオブジェクトをJSON文字列に変換
- WebSocketは文字列またはバイナリでデータを送信するため、変換が必須
```python
# 例
data = [{"id": 1, "name": "test"}]
json_str = json.dumps(data)  # '[{"id": 1, "name": "test"}]'
```

---

## 4. システムの動作フロー

### 4.1 全体のデータフロー

```
[フロントエンド]
    │
    │ (1) POST /api/simulations
    ↓
[バックエンド: start_simulation()]
    │
    │ (2) BackgroundTasks.add_task()
    ↓
[バックグラウンド: run_simulation_process()]
    │
    │ (3) subprocess.Popen("virtual_client.py")
    ↓
[仮想クライアント]
    │
    │ (4) シミュレーション実行
    │ (5) DBに結果書き込み
    │ (6) POST /api/notify-completion
    ↓
[バックエンド: notify_completion()]
    │
    │ (7) DBから結果取得・集計
    │ (8) manager.broadcast(JSON)
    ↓
[WebSocket接続クライアント全員]
    │
    │ (9) 画面自動更新
    ↓
[ユーザー: 最新結果を確認]
```

### 4.2 WebSocket接続のライフサイクル

```
[クライアント起動]
    │
    │ new WebSocket("ws://localhost:8000/ws/results")
    ↓
[サーバー: websocket_endpoint()]
    │
    │ manager.connect(websocket)
    │ active_connections.append(websocket)
    ↓
[接続維持中]
    │ while True: receive_text()
    │
    │ ← broadcast()が呼ばれたとき →
    │ send_text(message)
    ↓
[クライアント切断]
    │ WebSocketDisconnect例外発生
    │ manager.disconnect(websocket)
    ↓
[接続終了]
```

---

## 5. API仕様

### 5.1 POST /api/simulations - シミュレーション開始

**エンドポイント**: `POST http://localhost:8000/api/simulations`

**説明**: シミュレーションをバックグラウンドで開始する

**リクエスト**:
- ボディ: なし

**レスポンス**: `200 OK`
```json
{
  "message": "Simulation started."
}
```

**注意事項**:
- このAPIは即座にレスポンスを返す（非同期処理）
- 実際のシミュレーション完了は `/api/notify-completion` で通知される

---

### 5.2 POST /api/notify-completion - 完了通知受付

**エンドポイント**: `POST http://localhost:8000/api/notify-completion`

**説明**: シミュレーション完了を通知し、結果を全クライアントにブロードキャスト

**リクエスト**:
- ボディ: なし

**レスポンス**: `200 OK`
```json
{
  "message": "Notification sent."
}
```

**動作**:
1. DBから最新の集計結果を取得
2. WebSocket経由で接続中の全クライアントにブロードキャスト

---

### 5.3 WS /ws/results - WebSocket接続

**エンドポイント**: `WS ws://localhost:8000/ws/results`

**説明**: リアルタイムで結果通知を受け取るためのWebSocket接続

**サーバーからのメッセージ形式**:
```json
[
  {
    "scenario_id": 1,
    "scenario_name": "現状シナリオ",
    "average_total_costs": 9249.12,
    "average_delivery_rate": 0.85
  },
  {
    "scenario_id": 2,
    "scenario_name": "人員1名追加",
    "average_total_costs": 10500.00,
    "average_delivery_rate": 0.92
  }
]
```

**接続方法（JavaScriptの例）**:
```javascript
const ws = new WebSocket("ws://localhost:8000/ws/results");

ws.onopen = () => {
  console.log("WebSocket接続確立");
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log("受信:", data);
};

ws.onclose = () => {
  console.log("WebSocket切断");
};
```

---

## 6. テストプログラム

### 6.1 テストプログラムの場所

`backend/test_program/test_websocket.py`

### 6.2 テストの実行方法

**前提条件**:
- FastAPIサーバーが起動していること（`uvicorn main:app --reload`）
- データベースが起動していること

**実行コマンド**:
```bash
cd backend/test_program
python test_websocket.py
```

**期待される出力**:
```
=== WebSocket & Broadcast Test ===

1. WebSocketに接続中: ws://localhost:8000/ws/results
[OK] WebSocket接続成功

2. 完了通知APIを呼び出し中...
[OK] API応答: {'message': 'Notification sent.'}

3. WebSocketからのメッセージ受信を待機中...
[OK] メッセージ受信成功！

受信したデータ:
[]

=== テスト成功 ===
```

**注**: データベースにシミュレーション結果がない場合、空配列`[]`が返されますが、これは正常な動作です。

### 6.3 テストプログラムの解説

```python
import asyncio
import websockets
import requests
import json
import sys

sys.stdout.reconfigure(encoding='utf-8')

async def test_websocket_and_broadcast():
    uri = "ws://localhost:8000/ws/results"

    try:
        # (1) WebSocket接続確立
        async with websockets.connect(uri) as websocket:
            print("[OK] WebSocket接続成功\n")

            # (2) 完了通知APIを呼び出し
            response = requests.post("http://localhost:8000/api/notify-completion")
            print(f"[OK] API応答: {response.json()}\n")

            # (3) WebSocketからメッセージ受信（タイムアウト5秒）
            message = await asyncio.wait_for(websocket.recv(), timeout=5.0)
            print(f"[OK] メッセージ受信成功！\n")

            # (4) JSON解析して表示
            data = json.loads(message)
            print(json.dumps(data, indent=2, ensure_ascii=False))

    except asyncio.TimeoutError:
        print("[ERROR] タイムアウト: メッセージが受信できませんでした")

if __name__ == "__main__":
    asyncio.run(test_websocket_and_broadcast())
```

**学習ポイント**:

#### 1. **asyncio.run()**
- 非同期関数を実行するためのエントリーポイント
- Pythonのメイン関数で非同期処理を開始

#### 2. **async with websockets.connect()**
- コンテキストマネージャーでWebSocket接続を自動管理
- ブロック終了時に自動的に接続を閉じる

#### 3. **asyncio.wait_for()**
```python
message = await asyncio.wait_for(websocket.recv(), timeout=5.0)
```
- 非同期処理にタイムアウトを設定
- 5秒以内にメッセージが受信できなければ`TimeoutError`を発生

#### 4. **sys.stdout.reconfigure(encoding='utf-8')**
- Windows環境で日本語出力する際の文字化け防止
- デフォルトのcp932エンコードをUTF-8に変更

---

## 7. 動作確認手順

### 7.1 サーバー起動

```bash
cd backend
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

**確認ポイント**:
- コンソールに `Application startup complete.` が表示される
- エラーメッセージが出ていないこと

### 7.2 APIドキュメント確認

ブラウザで以下にアクセス:
```
http://localhost:8000/docs
```

**確認ポイント**:
- `POST /api/simulations` が表示されている
- `POST /api/notify-completion` が表示されている
- `GET /api/results` が表示されている（フェーズ1から継続）

**注**: WebSocketエンドポイントは、Swagger UIには表示されません（WebSocketはHTTPベースのSwaggerでは表現できないため）

### 7.3 WebSocketテスト実行

```bash
cd backend/test_program
python test_websocket.py
```

**期待される動作**:
1. WebSocket接続が確立される
2. 完了通知APIが正常に応答する
3. WebSocket経由でメッセージが受信される
4. `[OK]` マークが3つ表示される

### 7.4 サーバーログ確認

Uvicornのコンソールログで以下を確認:
```
INFO:     ('127.0.0.1', XXXXX) - "WebSocket /ws/results" [accepted]
INFO:     connection open
INFO:     127.0.0.1:XXXXX - "POST /api/notify-completion HTTP/1.1" 200 OK
INFO:     connection closed
```

**確認ポイント**:
- `WebSocket /ws/results [accepted]`: 接続が受け入れられた
- `connection open`: 接続が確立された
- `200 OK`: APIが正常に応答した
- `connection closed`: 接続が正常に閉じられた

---

## 8. フェーズ2の達成内容

✅ **完了項目**:
1. WebSocketコネクションマネージャーの実装
2. WebSocketエンドポイント実装（`WS /ws/results`）
3. シミュレーション開始API実装（`POST /api/simulations`）
4. 完了通知受付API実装（`POST /api/notify-completion`）
5. バックグラウンドタスク管理機能
6. テストプログラムの作成と動作確認

**技術的な達成**:
- 複数クライアントへの同時ブロードキャスト機能
- 非同期バックグラウンド処理
- WebSocketによるリアルタイム通信
- 外部プロセス起動機能

---

## 9. 次フェーズへの準備

フェーズ3では以下を実装予定：

### 9.1 仮想シミュレーションクライアント（virtual_client.py）

**目的**: FlexSimの代替としてシミュレーション処理を模擬する独立プログラム

**主な機能**:
1. ダミーデータ生成（総人件費、納期遵守率）
2. データベースへの結果書き込み
3. 処理時間の模擬（スリープ）
4. 完了通知APIへのリクエスト送信

**実装イメージ**:
```python
# virtual_client.py
import time
import random
import requests
from database import SessionLocal
from models import SimulationResult

def run_simulation():
    # 3つのシナリオ × 3レプリケーション
    for scenario_id in [1, 2, 3]:
        for replication in range(1, 4):
            # ダミーデータ生成
            cost = random.uniform(8000, 12000)
            rate = random.uniform(0.75, 0.95)

            # DB書き込み
            db = SessionLocal()
            result = SimulationResult(
                scenario_id=scenario_id,
                replication=replication,
                total_labor_costs=cost,
                ontime_delivery_rate=rate
            )
            db.add(result)
            db.commit()
            db.close()

            time.sleep(2)  # 処理時間を模擬

    # 完了通知
    requests.post("http://localhost:8000/api/notify-completion")

if __name__ == "__main__":
    run_simulation()
```

---

## 10. 学習課題（推奨）

フェーズ3に進む前に、以下のキーワードについて調査いただくことをお勧めします：

### 10.1 データベース操作
- **キーワード**: SQLAlchemy Session, commit, rollback, transaction
- **調査ポイント**:
  - トランザクションとは何か
  - commit()とrollback()の違い
  - セッション管理のベストプラクティス

### 10.2 乱数生成
- **キーワード**: random.uniform, random.seed, 再現性
- **調査ポイント**:
  - 乱数の生成方法
  - シード値による再現性
  - シミュレーションでの乱数の使い方

### 10.3 HTTPリクエスト
- **キーワード**: requests library, POST request, timeout
- **調査ポイント**:
  - requestsライブラリの使い方
  - エラーハンドリング
  - タイムアウト設定

---

## 11. トラブルシューティング

### 11.1 WebSocket接続エラー

**エラー**: `WebSocketException: invalid status code`

**原因と対処法**:
1. サーバーが起動していない → Uvicornを起動
2. ポート番号が間違っている → 8000番ポートを確認
3. CORSの問題 → `main.py`のCORS設定を確認

### 11.2 メッセージが受信できない

**症状**: `[ERROR] タイムアウト: メッセージが受信できませんでした`

**原因と対処法**:
1. WebSocket接続は確立しているが、`broadcast()`が呼ばれていない
2. `/api/notify-completion`が正常に動作していない
3. データベース接続エラー → サーバーログを確認

### 11.3 日本語が文字化けする

**症状**: コンソール出力が文字化けする（Windows環境）

**対処法**:
```python
import sys
sys.stdout.reconfigure(encoding='utf-8')
```
をスクリプトの先頭に追加

### 11.4 バックグラウンドプロセスが起動しない

**症状**: `/api/simulations`を呼んでも`virtual_client.py`が実行されない

**原因**:
- `virtual_client.py`がまだ存在しない（フェーズ3で実装予定）
- ファイルパスが間違っている

**確認方法**:
```python
import os
print(os.path.exists("virtual_client.py"))  # Falseなら存在しない
```

---

## 12. 補足資料

### 12.1 WebSocketとHTTPの比較表

| 特性 | HTTP (REST API) | WebSocket |
|------|----------------|-----------|
| **プロトコル** | http:// / https:// | ws:// / wss:// |
| **通信方向** | 単方向（クライアント→サーバー） | 双方向 |
| **接続** | リクエストごとに新規接続 | 1度確立したら維持 |
| **リアルタイム性** | ポーリング必要（定期的にリクエスト） | サーバーから即座にプッシュ |
| **オーバーヘッド** | 大（毎回HTTPヘッダー送信） | 小（初回のみハンドシェイク） |
| **ユースケース** | データ取得、更新、削除 | チャット、通知、ダッシュボード |

### 12.2 FastAPIの非同期処理パターン

```python
# パターン1: 通常の同期関数
@app.get("/sync")
def sync_endpoint():
    return {"message": "sync"}

# パターン2: 非同期関数
@app.get("/async")
async def async_endpoint():
    return {"message": "async"}

# パターン3: バックグラウンドタスク
@app.post("/background")
async def background_endpoint(background_tasks: BackgroundTasks):
    background_tasks.add_task(long_running_task)
    return {"message": "Task started"}

# パターン4: WebSocket
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # ...
```

### 12.3 Pythonの標準ライブラリ活用

**subprocess**: 外部プロセス起動
```python
import subprocess

# 起動して待つ
subprocess.run(["python", "script.py"])

# 起動して放置
subprocess.Popen(["python", "script.py"])
```

**json**: JSON変換
```python
import json

# Python → JSON文字列
json_str = json.dumps({"key": "value"})

# JSON文字列 → Python
data = json.loads('{"key": "value"}')
```

**asyncio**: 非同期処理
```python
import asyncio

async def main():
    await asyncio.sleep(1)
    print("1秒後")

asyncio.run(main())
```

---

## 13. まとめ

フェーズ2では、リアルタイム通知機能とシミュレーション制御機能を実装しました。

**主要な成果物**:
- WebSocketによるリアルタイム通信機能
- 複数クライアントへのブロードキャスト機能
- バックグラウンドタスク実行機能
- 完了通知トリガー機能

**技術的な学び**:
- 非同期処理（async/await）の実装
- WebSocketのライフサイクル管理
- バックグラウンドプロセスの起動と制御

**次のステップ**:
- フェーズ3: 仮想シミュレーションクライアントの実装

これにより、システムのコア機能が完成し、フロントエンドとの連携準備が整いました。

ご質問があれば、お気軽にお声がけください。